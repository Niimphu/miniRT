/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_scene.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: Kekuhne <kekuehne@student.42wolfsburg.d    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/01/12 19:21:56 by yiwong            #+#    #+#             */
<<<<<<< HEAD:src/raytrace/draw_scene.c
/*   Updated: 2024/01/28 20:24:23 by yiwong           ###   ########.fr       */
=======
/*   Updated: 2024/01/20 08:40:12 by Kekuhne          ###   ########.fr       */
>>>>>>> new_cylinders:src/raytrace/draw.c
/*                                                                            */
/* ************************************************************************** */

#ifndef BONUS

# include "miniRT.h"
# include "draw.h"
# include "msaa.h"

static t_xyz	get_ray(t_vars *data, t_camera *camera, int x, int y);
static void		draw_closest_shape(t_vars *mlx, t_camera *camera, t_rt *rt);
<<<<<<< HEAD:src/raytrace/draw_scene.c
static void		draw_closest_shape_msaa(t_vars *mlx, t_camera *camera,
					t_rt *rt);
=======
/* static void		print_pixel(t_rt *rt, int x, int y, t_intersect intersect); */
>>>>>>> new_cylinders:src/raytrace/draw.c

int	draw_scene(t_rt *rt)
{
	calculate_camera_right_up(rt->scene->camera);
	if (rt->msaa)
		draw_closest_shape_msaa(rt->mlx_data, rt->scene->camera, rt);
	else
		draw_closest_shape(rt->mlx_data, rt->scene->camera, rt);
	return (0);
}

static void	draw_closest_shape(t_vars *mlx, t_camera *camera, t_rt *rt)
{
	int			x;
	int			y;
	t_xyz		ray;
	t_intersect	intersect;

	y = 0;
	while (y < mlx->win_y)
	{
		x = 0;
		while (x < mlx->win_x)
		{
			ray = get_ray(mlx, camera, x, y);
			/* intersect = get_closest_shape(*camera->position, ray, rt->scene); */
			intersect = ray_intersects_cylinder(camera->position, ray, (t_cylinder *)rt->scene->cylinders->content);
			if (intersect.valid)
<<<<<<< HEAD:src/raytrace/draw_scene.c
				draw_pixel(rt, (t_xyz){x, y, 0}, intersect, ray);
			x++;
		}
		y++;
	}
}

static void	draw_closest_shape_msaa(t_vars *mlx, t_camera *camera, t_rt *rt)
{
	int			x;
	int			y;
	t_msaa		ray_info;

	y = 0;
	while (y < mlx->win_y)
	{
		x = 0;
		while (x < mlx->win_x)
		{
			ray_info = get_ray_info(rt, camera, x, y);
			ray_info = process_shadows(rt->scene, ray_info);
			print_pixel_msaa(rt, x, y, ray_info);
=======
			{
				mlx_pixel_put(rt->mlx_data->mlx, rt->mlx_data->win, x, y,
					cylinder_colour((t_cylinder *) intersect.shape,
					intersect.point, rt->scene));
			}
>>>>>>> new_cylinders:src/raytrace/draw.c
			x++;
		}
		y++;
	}
}

static t_xyz	get_ray(t_vars *data, t_camera *camera, int x, int y)
{
	double	dx;
	double	dy;
	double	scale;
	t_xyz	result;

	scale = tanf(0.5 * (float)camera->fov * (M_PI / 180.0));
	dx = scale * data->aspect_ratio * (((x + 0.5) / data->win_x) * 2.0 - 1.0);
	dy = scale * (1.0 - ((y + 0.5) / data->win_y) * 2.0);
	result = v_add(v_add(v_scale(camera->right, dx),
				v_scale(camera->up, dy)), *camera->forward);
	result = v_normalize(result);
	return (result);
}

<<<<<<< HEAD:src/raytrace/draw_scene.c
#endif
=======
/* static void	print_pixel(t_rt *rt, int x, int y, t_intersect intersect)
{
	if (intersect.type == SPHERE)
		mlx_pixel_put(rt->mlx_data->mlx, rt->mlx_data->win, x, y,
			sphere_colour((t_sphere *) intersect.shape,
				intersect.point, rt->scene));
	else if (intersect.type == PLANE)
		mlx_pixel_put(rt->mlx_data->mlx, rt->mlx_data->win, x, y,
			plane_colour((t_plane *) intersect.shape,
				intersect.point, rt->scene));
} */
>>>>>>> new_cylinders:src/raytrace/draw.c
